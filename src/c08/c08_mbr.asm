         ;代码清单8-1
         ;文件名：c08_mbr.asm
         ;文件说明：硬盘主引导扇区代码（加载程序） 
         ;创建日期：2011-5-5 18:17
         
         app_lba_start equ 100           ;声明常数（用户程序起始逻辑扇区号）
                                         ;常数的声明不会占用汇编地址
                                         ;120->伪指令equ，声明的数值不占用任何汇编地址，也不在运行时占用任何内存位置                           
SECTION mbr align=16 vstart=0x7c00
         ;114->Intel处理器要求段在内存中的起始物理地址按16字节对齐
         ;114->相应地，汇编语言源程序中定义的各个段，也有对齐方面的要求
         ;114->在段定义中,使用"align="子句，用于指定某个SECTION的汇编地址对齐方式
         ;114->"align=16"表示段是16字节对齐的       
         ;121->vstart=0x7c00，段内所有元素的汇编地址都将从0x7c00开始计算
         ;70->计算机启动后，总是把主引导程序加载到物理内存地址0x7c00处                            

         ;设置堆栈段和栈指针 
         mov ax,0      
         mov ss,ax
         mov sp,ax
         ;121->使用段超越前缀"cs:",意味着在访问内存单元时,使用cs的内容作为段基址
         mov ax,[cs:phy_base]            ;计算用于加载用户程序的逻辑段地址 
         mov dx,[cs:phy_base+0x02]
         mov bx,16        
         div bx            
         mov ds,ax                       ;令DS和ES指向该段以进行操作
         mov es,ax                        
    
         ;以下读取程序的起始部分 
         xor di,di
         mov si,app_lba_start            ;程序在硬盘上的起始逻辑扇区号 
         xor bx,bx                       ;加载到DS:0x0000处 
         call read_hard_disk_0           ;131->16位相对近调用,编译后的机器指令操作数是一个相对偏移量
                                         ;131->处理器执行这条指令时,用指令指针寄存器ip的内容加上指令中的偏移量,以及当前指令的长度,算出被调用过程的绝对偏移地址
                                         ;131->接着,将ip的现行值压栈。最后,用刚刚计算出的偏移地址替代ip的当前内容
      
         ;以下判断整个程序有多大
         mov dx,[2]                      ;曾经把dx写成了ds，花了二十分钟排错 
         mov ax,[0]
         mov bx,512                      ;512字节每扇区
         div bx
         cmp dx,0
         jnz @1                          ;未除尽，因此结果比实际扇区数少1 
         dec ax                          ;已经读了一个扇区，扇区总数减1 
;res + 1 == (x + 511) / 512
;res = (0 == x % 512) ? x / 512 - 1 : x / 512 
   @1:
         cmp ax,0                        ;考虑实际长度小于等于512个字节的情况 
         jz direct
         
         ;读取剩余的扇区
         push ds                         ;以下要用到并改变DS寄存器 

         mov cx,ax                       ;循环次数（剩余扇区数）

;133->每次往内存中加载一个扇区前,都重新在前面的数据尾部构造一个新的逻辑段,并把要读取的数据加载到这个新段内
;133->每次构造新段时,只需要在前面段地址的基础上增加0x20即可得到新段的段地址
   @2:
         mov ax,ds
         add ax,0x20                     ;得到下一个以512字节为边界的段地址
         mov ds,ax  
                              
         xor bx,bx                       ;每次读时，偏移地址始终为0x0000 
         inc si                          ;下一个逻辑扇区 
         call read_hard_disk_0
         loop @2                         ;循环读，直到读完整个功能程序 

         pop ds                          ;恢复数据段基址到用户程序头部段 
      
         ;计算入口点代码段基址 
   direct:
         mov dx,[0x08]
         mov ax,[0x06]
         call calc_segment_base
         mov [0x06],ax                   ;回填修正后的入口点代码段基址 
      
         ;开始处理段重定位表
         mov cx,[0x0a]                   ;需要重定位的项目数量
         mov bx,0x0c                     ;重定位表首地址
          
 realloc:
         mov dx,[bx+0x02]                ;32位地址的高16位 
         mov ax,[bx]
         call calc_segment_base
         mov [bx],ax                     ;回填段的基址
         add bx,4                        ;下一个重定位项（每项占4个字节） 
         loop realloc 
      
         jmp far [0x04]                  ;转移到用户程序
                                         ;139-140->16位间接绝对远转移,16位的意思是:要转移到的目标位置的偏移地址是16位的
                                         ;139->访问段寄存器DS所指向的数据段,从指令中给出的偏移地址处取出两个字,分别用来替代指令指针寄存器ip和段寄存器cs的内容  
 
;-------------------------------------------------------------------------------
;128->一般来说,过程的第一条指令需要一个标号,以方便引用该过程
;128->参数传递最简单的办法是通过寄存器
;126->lba28访问硬盘
;125->块设备硬盘读写的基本单位是扇区
;125->最早的逻辑扇区编址方法是lba28,使用28个比特来表示逻辑扇区号,从逻辑扇区0x0000000到0xFFFFFFF,每个扇区512字节
read_hard_disk_0:                        ;从硬盘读取一个逻辑扇区
                                         ;输入：DI:SI=起始逻辑扇区号
                                         ;      DS:BX=目标缓冲区地址
         push ax
         push bx
         push cx
         push dx
      
         mov dx,0x1f2                    ;126->设置要读取的扇区数量,这个数值要写入0x1f2端口
                                         ;126->0x1f2是一个8位端口,因此每次最多只能读写256个扇区
                                         ;126->如果写入的值为0,则表示要读取256个扇区
                                         ;126->每读一个扇区,这个数值就减1。因此,如果在读写过程中发生错误,该端口包含着尚未读取的扇区数
         mov al,1                        ;126->1个扇区
         out dx,al                       ;读取的扇区数
                                         ;125->out指令目的操作数可以是8位立即数或者寄存器DX,源操作数必须是寄存器AL或者AX
                                         ;124->在intel的系统中,只允许65536个端口存在,端口号从0到65535
                                         ;125->和in指令一样,out指令不影响任何标志位

;126->设置起始lba扇区号。扇区的读写是连续的,因此只需要给出第一个扇区的编号就可以了
;126->28位的扇区号太长,需要将其分成4段,分别写入端口0x1f3、0x1f4、0x1f5和0x1f6号端口
;126->0x1f3号端口存放的是0-7位
;126->0x1f4号端口存放的是8-15位
;126->0x1f5号端口存放的是16-23位
;126->0x1f6号端口存放的是24-27位
;126->在现行的体系下,每个PATA/SATA接口允许挂接两块硬盘,分别是主盘和从盘
;126->0x1f6端口的低4位用于存放逻辑扇区号的24-27位,第4位用于指示硬盘号,0表示主盘,1表示从盘。高3位是'111',表示lba模式

         inc dx                          ;0x1f3
         mov ax,si
         out dx,al                       ;LBA地址7~0

         inc dx                          ;0x1f4
         mov al,ah
         out dx,al                       ;LBA地址15~8

         inc dx                          ;0x1f5
         mov ax,di
         out dx,al                       ;LBA地址23~16

         inc dx                          ;0x1f6
         mov al,0xe0                     ;LBA28模式，主盘
         ;or al,ah                        ;LBA地址27~24
         out dx,al

         inc dx                          ;0x1f7
         mov al,0x20                     ;读命令
                                         ;126->向端口0x1f7写入0x20,请求硬盘读。这也是一个8位端口
                                         ;127->通过0x1f7端口发送写命令之后,硬盘就忙乎开了
         out dx,al

;127->等待读写操作完成。端口0x1f7即是命令端口,又是状态端口
;127->硬盘内部操作期间,硬盘将0x1f7端口的第7位置'1',表明自己很忙。
;127->一旦硬盘系统准备就绪,它再将此位清零,同时将位3置'1',意思是准备好了,请求主机发送或者接收数据
  .waits:
         in al,dx
         and al,0x88
         cmp al,0x08
         jnz .waits                      ;不忙，且硬盘已准备好数据传输
                                         ;91->ZF = 0,则跳转 

         mov cx,256                      ;总共要读取的字数
         mov dx,0x1f0                    ;127->0x1f0是硬盘接口的数据端口,而且还是一个16位端口
  .readw:
         in ax,dx
         mov [bx],ax
         add bx,2
         loop .readw

         pop dx
         pop cx
         pop bx
         pop ax
      
         ret                             ;131->ret是近返回指令,当它执行时,处理器从栈中弹出一个字到指令指针寄存器ip中

;-------------------------------------------------------------------------------
calc_segment_base:                       ;计算16位段地址
                                         ;输入：DX:AX=32位物理地址
                                         ;返回：AX=16位段基地址 
         push dx                          
         
         add ax,[cs:phy_base]
         adc dx,[cs:phy_base+0x02]  
         shr ax,4                        ;136->逻辑右移指令执行时,会将操作数连续地向右移动指定地次数
                                         ;136->每移动一次,“挤”出来的比特被移到标志寄存器的CF位,左边空出来的位置用比特'0'填充
         ror dx,4                        ;137->循环右移指令执行时,每右移一次,移出的比特即送到标志寄存器的CF位,也送进左边空出的位
         and dx,0xf000
         or ax,dx
         
         pop dx
         
         ret

;-------------------------------------------------------------------------------
         phy_base dd 0x10000             ;用户程序被加载的物理起始地址
         
 times 510-($-$$) db 0
                  db 0x55,0xaa

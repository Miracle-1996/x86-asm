         ;代码清单11-1
         ;文件名：c11_mbr.asm
         ;文件说明：硬盘主引导扇区代码 
         ;创建日期：2011-5-16 19:54

         ;设置堆栈段和栈指针 
         mov ax,cs      
         mov ss,ax
         mov sp,0x7c00
      
         ;计算GDT所在的逻辑段地址 
         mov ax,[cs:gdt_base+0x7c00]        ;低16位 
         mov dx,[cs:gdt_base+0x7c00+0x02]   ;高16位 
         mov bx,16        
         div bx            
         mov ds,ax                          ;令DS指向该段以进行操作
         mov bx,dx                          ;段内起始偏移地址 
          
         ;191->处理器规定,gdt中的第一个描述符必须是空描述符,或者叫哑描述符或null描述符
         ;191->很多时候,寄存器和内存单元的初始值会为0,再加上程序设计有问题,就会在无意中用全0的索引来选择描述符
         ;191->因此,处理器要求将第一个描述符定义成空描述符
         ;188->每个描述符在gdt中占8字节
         ;创建0#描述符，它是空描述符，这是处理器的要求
         mov dword [bx+0x00],0x00
         mov dword [bx+0x04],0x00  

         ;188->全局描述符表高双字
         ;188->31-24          23  22   21  20   19-16   15 14-13  12  11-8   7-0 
         ;188->段基地址31-24  G   D/B  L   AVL  段界限  P  DPL    S   TYPE   段基地址23-16
         ;189->G位是粒度位,用于解释段界限的含义。当G位是'0'时,段界限以字节为单位。如果该位是'1',段界限是以4kb为单位
         ;189->D/B位是"默认的操作数大小"或者"默认的栈指针大小"又或者“上部边界”标志
         ;189->对于代码段,此位称做D位。用于指示指令中默认的偏移地址和操作尺寸。0:16 1:32
         ;189->对于栈段,该位被叫做B位。用于在进行隐式的栈操作时,是使用sp寄存器还是esp寄存器。0:sp 1:esp
         ;190->同时,B位的值也决定了栈的上部边界。B = 0->0xffff  B = 1->0xffffffff
         ;190->L位是64位代码段标志,保留此位给64位处理器使用
         ;190->AVL是软件可以使用的位,通常由操作系统来用,处理器并不使用它
         ;189->P位是段存在位。P位用于指示描述符所对应的段是否存在
         ;189->DPL表示描述符特权级,指定段的特权级
         ;189->S位用于指定描述符的类型。0:系统段 1:代码段或者数据段(栈段也是特殊的数据段)
         ;190->TYPE字段共4位,用于指示描述符的子类型,或者说是类别

         ;创建#1描述符，保护模式下的代码段描述符
         ;188->全局描述符表低双字
         ;188->31-16           15-0
         ;188->段基地址15-0    段界限15-0

         ;191->线性基地址0x00007c00 段界限0x001ff
         ;191->G = 0 代码段
         ;190->TYPE：1000 只执行
         mov dword [bx+0x08],0x7c0001ff     
         mov dword [bx+0x0c],0x00409800     

         ;创建#2描述符，保护模式下的数据段描述符（文本模式下的显示缓冲区）
         ;191->线性基地址0x000b8000 段界限0x0ffff
         ;191->G = 0 数据段
         ;191->TYPE:0010 读、写
         mov dword [bx+0x10],0x8000ffff     
         mov dword [bx+0x14],0x0040920b     

         ;创建#3描述符，保护模式下的堆栈段描述符
         ;192->线性基地址0x00000000 段界限0x07a00
         ;192->G = 0 数据(栈)段
         ;192->TYPE:0110 读、写、向下扩展
         mov dword [bx+0x18],0x00007a00
         mov dword [bx+0x1c],0x00409600

         ;初始化描述符表寄存器GDTR
         ;186->为了跟踪全局描述符表,处理器内部有一个48位寄存器gdtr
         ;186->该寄存器分为两部分,分别是32位的线性地址和16位的边界
         ;186->gdtr的32位线性基地址部分保存的是全局描述符表在内存中的起始线性地址
         ;186->16位边界部分保存的是全局描述符表的边界(界限),其在数值上等于表的大小(总字节数)减1
         mov word [cs: gdt_size+0x7c00],31  ;描述符表的界限（总字节数减一）   
         ;192->lgdt操作数是一个48位(6字节)的内存区域。在16位模式下,该地址是16位的,在32位模式下,该地址是32位的
         ;192->该指令在实模式和保护模式下都可以执行
         ;192->6字节的内存区域中,低16位是gdt的界限值,高32位是gdt的基地址
         ;192->计算机启动之后,gdtr的基地址被初始化为0x00000000;界限值为0xffff                                
         lgdt [cs: gdt_size+0x7c00]
         ;194->输入输出控制器集中芯片ich的处理器接口部分,有一个用于兼容老式设备的端口0x92
         ;194->端口0x92的位1用于控制A20
         ;194->端口0x92是可读写的
         in al,0x92                         ;南桥芯片内的端口 
         or al,0000_0010B
         out 0x92,al                        ;打开A20

         ;195->保护模式下的中断机制和实模式不同,因此,原有的中断向量表不再适用
         ;195->在保护模式下,bios中断都不能使用,因为它们是实模式下的代码
         ;195->在重新设置保护模式下的中断环境之前,必须关中断
         cli                                ;保护模式下中断机制尚未建立，应 
                                            ;禁止中断 
         ;195->cr0是32位寄存器,包含了一系列用于控制处理器操作模式和运行状态的标志位
         ;195->cr0的第1位(位0)是保护模式允许位。该位置1,处理器进入保护模式,按保护模式的规则开始运行
         mov eax,cr0
         or eax,1
         mov cr0,eax                        ;设置PE位
      
         ;以下进入保护模式... ...
         ;该指令默认地用'bits 16'编译。关键字dword修饰偏移地址,要求使用32位的偏移量
         jmp dword 0x0008:flush             ;16位的描述符选择子：32位偏移
                                            ;清流水线并串行化处理器 
         [bits 32] 

    flush:
         mov cx,00000000000_10_000B         ;加载数据段选择子(0x10)
         mov ds,cx

         ;以下在屏幕上显示"Protect mode OK." 
         mov byte [0x00],'P'  
         mov byte [0x02],'r'
         mov byte [0x04],'o'
         mov byte [0x06],'t'
         mov byte [0x08],'e'
         mov byte [0x0a],'c'
         mov byte [0x0c],'t'
         mov byte [0x0e],' '
         mov byte [0x10],'m'
         mov byte [0x12],'o'
         mov byte [0x14],'d'
         mov byte [0x16],'e'
         mov byte [0x18],' '
         mov byte [0x1a],'O'
         mov byte [0x1c],'K'

         ;以下用简单的示例来帮助阐述32位保护模式下的堆栈操作 
         mov cx,00000000000_11_000B         ;加载堆栈段选择子
         mov ss,cx
         mov esp,0x7c00

         mov ebp,esp                        ;保存堆栈指针 
         push byte '.'                      ;压入立即数（字节）
         
         sub ebp,4
         cmp ebp,esp                        ;判断压入立即数时，ESP是否减4 
         jnz ghalt                          
         pop eax
         mov [0x1e],al                      ;显示句点 
      
  ghalt:     
         hlt                                ;已经禁止中断，将不会被唤醒 

;-------------------------------------------------------------------------------
     
         gdt_size         dw 0
         gdt_base         dd 0x00007e00     ;GDT的物理地址 
                             
         times 510-($-$$) db 0
                          db 0x55,0xaa
         ;代码清单6-1
         ;文件名：c06_mbr.asm
         ;文件说明：硬盘主引导扇区代码
         ;创建日期：2011-4-12 22:12 
      
         jmp near start
  ;77->在NASM里,"\"是续行符,当一行写不下时,可以在行尾使用这个符号,以表明下一行与当前行应该合并为一行
  mytext db 'L',0x07,'a',0x07,'b',0x07,'e',0x07,'l',0x07,' ',0x07,'o',0x07,\
            'f',0x07,'f',0x07,'s',0x07,'e',0x07,'t',0x07,':',0x07
  number db 0,0,0,0,0
  
  start:
         mov ax,0x7c0                  ;设置数据段基地址 
         mov ds,ax
                                       ;77->0x0000:0x7c00 == 0x07c0:0000
         
         mov ax,0xb800                 ;设置附加段基地址 
         mov es,ax
         
         ;78->8086处理器提供movsb和movsw指令用于把数据从内存中的一个地方批量地传送(复制)到另一个地方,处理器把它们看成是数据串
         ;78->movsb的传送是以字节为单位,而movsw的传送是以字为单位
         ;78->movsb和movsw指令执行时,原始数据串的段地址由ds指定,偏移地址由si指定，简写为ds:si
         ;78->要传送到的目的地址由es:di指定
         ;78->传送的字节数(movsb)或者字数(movsw)由cx指定
         ;78->除此之外,还要指定是正向传送还是反向传送
         ;78->正向传送是指传送操作的方向是从内存区域的低地址端到高地址端,反向传送则正好相反
         ;78->正向传送时,每传送一个字节(movsb)或者一个字(movsw),si和di +1 / +2
         ;78->反向传送时,每传送一个字节(movsb)或者一个字(movsw),si和di -1 / -2
         ;78->每传送一次,cx的内容自动减1
         ;78->8086处理器里有标志寄存器FLAGS
         ;79->FLAGS第10位是方向标志DF

         cld                           ;79->方向标志清零指令cld
                                       ;79->cld指令将DF标志清零,以指示传送是正方向的
         mov si,mytext                 
         mov di,0
         mov cx,(number-mytext)/2      ;实际上等于 13
         rep movsw                     ;79->单纯的movsb和movsw只能执行一次
                                       ;79->如果希望处理器自动地反复执行,需要加上指令前缀rep,意思是cx不为0则重复
     
         ;得到标号所代表的偏移地址
         mov ax,number
         
         ;计算各个数位
         mov bx,ax                     ;80->mov ax,number与mov bx,ax等效于mov bx,number
                                       ;80->但用寄存器传递来得更快,更方便

         ;80->loop指令:
         ;80->将寄存器cx的内容减1
         ;80->如果cx的内容不为0,转移到指定的位置处执行,否则顺序执行后面的指令
         mov cx,5                      ;循环次数 
         mov si,10                     ;除数 
                                       ;16->si是一个16位的通用寄存器
  digit: 
         xor dx,dx
         div si
         mov [bx],dl                   ;保存数位
                                       ;80->在8086处理器上,如果要有寄存器来提供偏移地址,只能使用bx,si,di,bp,不能使用其他寄存器
                                       ;81->注意,可以在任何带有内存操作数的指令中使用bx,si或者di提供偏移地址
         inc bx 
         loop digit                    ;80->和jmp near类似,在编译阶段,编译器用标号digit所在位置的汇编地址减去loop指令的汇编地址,再减去loop指令的长度得到操作数
         
         ;显示各个数位
         mov bx,number 
         mov si,4                      
   show:
         mov al,[bx+si]                ;87->intel-8086处理器只允许以下几种基址寄存器和变址寄存器的组合:
                                       ;87->[bx + si] [bx + di] [bp + si] [bp + di]
                                       ;87->这些组合可以用于任何带有内存操作数的指令中
         add al,0x30
         mov ah,0x04                   ;87->0x04是显示属性-黑底红字，无加亮，无闪烁
         mov [es:di],ax
         add di,2
         dec si
         jns show                      ;87->如果未设置符号位,则转移到标号"show"所在的位置处执行
                                       ;87->intel处理器的标志寄存器里由符号位SF
                                       ;87->此处dec指令会影响该位,如果计算结果的最高位是比特0,处理器把SF位置'0',否则SF位置'1'
                                       ;88->它和jmp指令很相似,也是相对转移指令,编译后的机器指令操作数也是一个相对偏移量,
                                       ;88->是用标号处的汇编地址减去当前指令的汇编地址，再减去当前指令的长度得到的
         mov word [es:di],0x0744       ;92->字的写入是按低端字节序的

         jmp near $                    ;93->nasm编译器提供了一个标记'$',该标记等同于标号
                                       ;93->jmp near $的意思是,转移到当前指令继续执行

  times 510-($-$$) db 0                ;93->"$$"是nasm编译器提供的另一个标记,代表当前汇编节(段)的起始汇编地址
                                       ;93->当前程序没有定义节或段,就默认地自成一个汇编段,而且起始的汇编地址是0(程序起始处)
                                       ;93->这样,用当前汇编地址减去程序开头的汇编地址(0),就是程序实体的大小
                   db 0x55,0xaa